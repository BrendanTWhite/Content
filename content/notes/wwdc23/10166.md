---
contributors: JohnBaer3, multitudes
---

## Chapters
[1:15 - Overview](https://developer.apple.com/videos/play/wwdc2023/10166/?time=75)  
[5:10 - Create a macro using Xcode's macro template](https://developer.apple.com/videos/play/wwdc2023/10166/?time=310)  
[10:50 - Macro roles](https://developer.apple.com/videos/play/wwdc2023/10166/?time=650)  
[11:40 - Write a SlopeSubset macro to define an enum subset](https://developer.apple.com/videos/play/wwdc2023/10166/?time=700)  
[20:17 - Inspect the syntax tree structure in the debugger](https://developer.apple.com/videos/play/wwdc2023/10166/?time=1217)  
[24:35 - Add a macro to an Xcode project](https://developer.apple.com/videos/play/wwdc2023/10166/?time=1475)  
[27:05 - Emit error messages from a macro](https://developer.apple.com/videos/play/wwdc2023/10166/?time=1625)  
[30:12 - Generalize SlopeSubset to a generic EnumSubset macro](https://developer.apple.com/videos/play/wwdc2023/10166/?time=1812)  

## ELI5 Summary of Macros: 
Imagine you're baking a cake, and you need to sift flour. You have to get out your sifter, pour in the flour, turn the handle... and you have to do this every single time you need sifted flour. Now imagine you had a magical kitchen helper who could do this for you. All you'd have to say is "sift flour" and it's done!
Swift macros are like that magical kitchen helper, but for your code. Instead of you having to write out the same lines of code over and over again, you just tell your macro (your kitchen helper) what to do. This might be something like "create a struct with these properties" or "set up a standard network request".
You define how the macro works one time, and then you can use it whenever you need to. It's a way to automate repetitive tasks and make your code easier to read and manage. This makes coding a lot faster and less prone to errors, especially as your projects get bigger and more complex.

# Overview

Swift macros allow you to generate that repetitive code at compile time, making your app's codebases more expressive and easier to read.

Here we have a list of calculations that first-year students can use to practice their arithmetic skills. We have the result as an integer on the left and the calculation as a string literal on the right side of the tuple. Notice how this is repetitive, redundant, and even error prone because nobody can guarantee that the result actually matches the calculation.

```swift
let calculations = [
(1 + 1, "1 + 1"),
(2 + 3, "2 + 3"),
(7 - 3, "7 - 3"),
(5 - 2, "5 - 2"),
(3 * 2, "3 * 2"),
(3 * 5, "3 * 5"),
]
```

With Swift 5.9 we can define a stringify macro to simplify this. This macro also happens to be the one that is included in Xcode's template. The stringify macro only takes the calculation as a single parameter. At compile time it expands to the tuple that we saw before, guaranteeing that the calculation and the result match.

```swift
let calculations = [
	#stringify(1 + 1), 
	#stringify(2 + 3), 
	#stringify(7 - 3), 
	#stringify(5 - 2), 
	#stringify(3 * 2), 
	#stringify(3 * 5),
]
```

So how does this work? Let's take a look at the definition of the macro itself. Notice that it looks a lot like a function.

```swift
@freestanding(expression)
macro stringify(_ value: Int) -> (Int, String)
```

The stringify macro takes an integer as the input parameter and outputs a tuple containing an the result, an integer, and the calculation-- a string. If the arguments of the macro expression don't match the macro's parameters, or don't type check by themselves, the compiler will emit an error without applying the macro expansion. 

For example, if I pass a string literal to this macro, the compiler complains that 'String' is not convertible to expected argument type 'Int'.

![Example of repetitive code][example1]

[example1]: ../../../images/notes/wwdc23/10166/example1.jpg

This is different to, for example, C macros, which are evaluated at the pre-processor stage before type-checking. But it allows us to use all the powers that you know and love from Swift functions, like being able to make your macro generic.

Also note that this macro is declared with the freestanding expression macro role. This means that you can use the macro wherever you can use an expression, and that it will be indicated by the hash character, like we see with #stringify.  

Other kinds of macros are attached macros that can augment declarations. We will cover those later. After checking that all the arguments match the macro's parameters, the compiler performs the macro expansion. To see how that works, let's focus on a single macro expression.

## Macro plug-in

To perform the expansion, each macro defines its implementation in a compiler plug-in. The compiler will send the source code of the entire macro expression to that plug-in.  The first thing that the macro plug-in does, is to parse the source code of the macro into a SwiftSyntax tree. This tree is a source-accurate, structural representation of the macro, and it will be the basis on which the macro operates. For example, our 'stringify' macro is represented in the tree as a macro expansion expression node. That expression has the macro name 'stringify'. And it takes a single argument, which is the infix operator plus applied to 2 and 3.

![Example of macro expansion][macro]

[macro]: ../../../images/notes/wwdc23/10166/macro.jpg

What's really powerful about Swift macros is that that the macro's implementation is itself a program written in Swift and can perform any transformation to the syntax tree it wants. In our case, it generates a tuple like we saw before. It will then serialize the generated syntax tree into source code again and send it to the compiler, which will replace the macro expression by the expanded code.

![Example of macro expansion][macro1]

[macro1]: ../../../images/notes/wwdc23/10166/macro1.jpg

# Create a macro

The new macro template in Xcode defines the stringify macro that we have just seen. Let us walk through that template and explore the macro's definition, how the expansion works, and how the macro can be tested. 

To create the template, I click File, New, Package, and now I select the Swift Macro template. Let's call our first macro "WWDC".

So what do we get with the template? Here we have an invocation of the #stringify macro, similar to what we have seen before. It takes a parameter "a + b" and returns the result, as well as the code that produced it. 

![Example of macro expansion][macro2]

[macro2]: ../../../images/notes/wwdc23/10166/macro2.jpg

If I want to know what the macro expands to, I can right-click on it and select Expand Macro.

![Example of macro expansion][macro3]

[macro3]: ../../../images/notes/wwdc23/10166/macro3.jpg

That's exactly what we saw before. 

![Example of macro expansion][macro4]

[macro4]: ../../../images/notes/wwdc23/10166/macro4.jpg

But how is the macro defined? Let's jump to its definition. (right click again, first manu item from top).

Here we have a slightly generalized version of our previous 'stringify' macro. Instead of taking an integer, this macro is generic and can receive any type T. The macro is declared as an external macro.

![Example of macro expansion][macro5]

[macro5]: ../../../images/notes/wwdc23/10166/macro5.jpg

This tells the compiler that to perform the expansion, it needs to look at the StringifyMacro type in the WWDCMacros module.

How is that type defined? 

** command - shift - o / type "stringify" and select from search "StringifyMacro" ** 

Let's take a closer look at it. Because stringify is declared as a freestanding expression macro, the StringifyMacro type needs to conform to the ExpressionMacro protocol.This protocol has a single requirement: The expansion function. It takes the syntax tree of the macro expression itself, as well as a context that can be used to communicate with the compiler.

The expansion function then returns the rewritten expression syntax.

What does it do in the implementation? At first, it retrieves the single argument to the macro expression. It knows that this argument exists because stringify is declared as taking a single parameter and all arguments need to type-check before the macro expansion can be applied. It then uses string interpolation to create the syntax tree of a tuple. The first element is the argument itself and the second is a string literal containing the source code of the argument.

```swift
// StringifyMacro implementation
public struct StringifyMacro: ExpressionMacro {
	public static func expansion(
		of node: some FreestandingMacroExpansionSyntax, 
		in context: some MacroExpansionContext
	) -> ExprSyntax {
		guard let argument = node.argumentList.first?.expression else {
			fatalError "compiler bug: the macro does not have any arguments")
		}
		
		return "(\(argument), \(literal: argument.description))"
	}
}
```

The function is not returning a string here. It is returning an expression syntax. The macro will automatically invoke the Swift parser to transform this literal into a syntax tree. And because it is using the literal interpolation style for the second argument, it will make sure that the literal's contents are properly escaped. 

Because macros don't have side effects and the source code of syntax trees is easy to compare, a great way to test them is to write unit tests. The macro template already comes with one.


```swift
// stringify test case

final class WWDCTests: XCTestCase {
	func testMacro() {
		assertMacroExpansion(
			"""
			#stringify(a + b)
			""",
			expandedSource: """
			(a + b, "a + b")
			""",
			macros: testMacros
		)
	}
}

let testMacros: [String: Macro.Type] = [
	"stringify": StringifyMacro.self
]
```

This test case uses the 'assertMacroExpansion' function from the SwiftSyntax package to verify that the 'stringify' macro expands correctly.

It takes the '#stringify(a + b)' expression, that we saw before, as input. and asserts that after the macro is expanded, it produces a tuple containing 'a + b' and the string literal 'a + b'.

To tell the test case how to expand the macros, it passes the 'testMacros' parameter, which specifies that the macro ‘#stringify' should be expanded using the 'StringifyMacro' type. Let's run the tests in the same way that you might already run the tests of your app, to see if they indeed pass.

The tests pass, and with that, we already have our first macro.

![Example of macro expansion][macro6]

[macro6]: ../../../images/notes/wwdc23/10166/macro6.jpg

## Swift macro template recap

- Macro declaration defines the macro's signature
- Implementation operates on SwiftSyntax trees
- Easy to test


# Macro roles

We have already seen a freestanding expression macro. This macro is spelled with a **hash** and allows you to rewrite the entire macro expression. There's also a freestanding declaration role that expands to a declaration instead of an expression. The other kinds of macros are attached macros. These are spelled with an @, just like attributes, and allow the macro to augment the declaration they are attached to. For example, an attached member macro adds new members of the type it is attached to. 

Macro roles| Description
|:------------|--:|
|@freestanding(expression)| Creates a piece of code that returns a value|
|@freestanding(declaration) |Creates one or more declarations|
|@attached(peer)|Adds new declarations alongside the declaration it's applied to|
|@attached(accessor)|Adds accessors to a property|
|@attached (memberAttribute)|Adds attributes to the declarations in the tvpe/extension it's applied to|
|@attached(member)|Adds new declarations inside the type/extension it's applied to|
|@attached(conformance)|Adds conformances to the tvpe/extension it's applied to|

To learn more about these other roles, I highly recommend watching "Expand on Swift macros":

[Expand on Swift macros](https://developer.apple.com/videos/play/wwdc2023/10167)  

But I want to focus on the attached member role because it helped me improve the codebase of an app I am currently working on. I am also a ski instructor, and recently I have been working on an app that allows me to plan the tours I want to take my students on. One thing you absolutely want to avoid as a ski instructor is to take beginners on slopes that are too hard for them. I want to use the Swift type system to enforce that. 

That's why, in addition to the Slope enum that contains all the slopes in my favorite ski resort, I also have an EasySlope type that only contains slopes suitable for beginners. It has an initializer to convert a slope to an easy slope, if the slope is indeed easy, and a computed property to convert an easy slope back to a general slope.
```swift
// Slopes in my favorite ski resort.
enum Slope {
	case beginnersParadise 
	case practiceRun 
	case livingRoom 
	case olympicRun 
	case blackBeauty
 }

// Slopes suitable for beginners. Subset of 'Slopes'.
enum EasySlope {
	case beginnersParadise 
	case practiceRun
	
	init?(_ slope: Slope) {
		switch slope {
		case .beginnersParadise: self = .beginnersParadise
		case .practiceRun: self = .practiceRun
		default: return nil
		}
	}
	
	var slope: Slope {
		switch self {
			case .beginnersParadise: return .beginnersParadise 
			case .practiceRun: return .practiceRun
		}
	}
}
```

![Example of macro expansion][macro7]

[macro7]: ../../../images/notes/wwdc23/10166/macro7.jpg

While this provides great type safety, it is really repetitive. If I want to add an easy slope, I need to add it to Slope...

EasySlope, the initializer, and the computed property. Let's see if we can improve things using a macro. 

What we want to do is to automatically generate the initializer and the computed property. How can we do this? 

### The Plan

- Declare attached member macro
Both the initializer and the computed property are members of the EasySlope type, so we need to declare an attached member macro.  

- Create empty macro implementation

Next, we will create the compiler plug-in that contains the macro's implementation. To make sure that our macro behaves as expected, we want to develop it in a test-driven way. 

- Create test case
Thus, we will leave its implementation empty until we write a test case for it.  

- Write macro implementation
After we defined the macro's behavior in a test case, we will write the implementation to match that test case.

- Integrate macro into app
And finally, we will integrate the new macro into my app. 

If all goes well, we will be able to remove the initializer and have the macro generate it for us.

To develop the macro, we work with the template that we created earlier. And since I don't really need the ‘#stringify' macro in my app, I have already removed it. I start by declaring a new attached member macro by using the '@attached(member)' attribute.

I call it SlopeSubset because EasySlope is a subset of Slope.

The macro also defines the names of the members it introduces.
```swift
/// Defines a subset of the 'Slope' enum
///
/// Generates an initializer that converts a 'Slope' to this type if the slope is
/// declared in this subset, otherwise returns nil
///
/// - Important: All enum cases declared in this macro must also exist in the
/// Slope enum.
@attached (member, names: named(init))
public macro SlopeSubset() = #externalMacro(module: "WWDCMacros", type: "SlopeSubsetMacro")
```

![Example of macro expansion][macro8]

[macro8]: ../../../images/notes/wwdc23/10166/macro8.jpg

In this demo, I will just be showing you how to generate the initializer. Generating the computed property is very similar, because it's also just a switch statement that switches over all the cases. With this declaration, we have defined the macro, but we have not implemented the expansion that it actually performs.  For this, our macro references the SlopeSubsetMacro type in the WWDCMacros module . Let us go and create that type so we can continue to the really exciting part: The actual macro implementation. 

Since we declared SlopeSubset as an attached member macro, the corresponding implementation needs to conform to the MemberMacro protocol. This protocol has a single requirement: The 'expansion' function, similar to ExpressionMacro.

```swift
import SwiftCompilerPlugin
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros

/// Implementation of the 'SlopeSubset macro.
public struct SlopeSubsetMacro: MemberMacro {
	// members
}

@main
struct WWDCPlugin: CompilerPlugin {
	let providingMacros: [Macro.Type] = [
		...

	]
}
```

![Example of macro expansion][macro9]

[macro9]: ../../../images/notes/wwdc23/10166/macro9.jpg

The 'expansion' function takes the attribute with which we apply the macro to a declaration, as well as the declaration that the macro is being applied to. In our case, this will be the EasySlope enum declaration.

The macro then returns the list of all the new members it wants to add to that declaration.

```swift
import SwiftCompilerPlugin
import SwiftSyntax
import SwiftSyntaxBuilder
import SwiftSyntaxMacros

/// Implementation of the 'SlopeSubset macro.
public struct SlopeSubsetMacro: MemberMacro {
	public static func expansion(
		of attribute: AttributeSyntax,
		providingMembers0f deciaration: some DeclGroupSyntax,
		in context: some MacroExpansionContext
	) throws -> [DeclSyntax] {
		return []  // for now to test
	}
}

@main
struct WWDCPlugin: CompilerPlugin {
	let providingMacros: [Macro.Type] = [
		SlopeSubsetMacro.self
	]
}
```

![Example of macro expansion][macro10]

[macro10]: ../../../images/notes/wwdc23/10166/macro10.jpg

I know that it's very tempting to start implementing this transformation straight away, but we agreed that we wanted to start by writing a test case for it. So for now, let us just return an empty array, indicating that no new members should be added.

Finally, we need to make SlopeSubset visible to the compiler. For this, I add it to the 'providingMacros' property down here.

Before diving any deeper, I want to make sure that what we have so far works. While I could try applying the macro in Xcode and looking at the expanded code, I much prefer to write a test case for it that I can rerun whenever I'm making changes to the macro, to make sure I'm not introducing regressions.

Just like in the test case in the template, we use the 'assertMacroExpansion' function to verify our macro's behavior.

```swift
import SwiftSyntaxMacros
import SwiftSyntaxMacrosTestSupport
import XCTest
import WWDCMacros

let testMacros: [String: Macro.Type] = [
	"SlopeSubset" : SlopeSubsetMacro.self,
]

final class WWDCTests: XCTestCase {
	func testSlopeSubset () {
		assertMacroExpansion (
			"""
			@SlopeSubset
			enum EasySlope {
			case beginnersParadise 
			case practiceRun
			}
			""",expandedSource:
			"""

			enum EasySlope {
				case beginnersParadise 
				case practiceRun
			}
			""", macros: testMacros)
	}
}
```
What we want to test is what the macro generates when applied to the EasySlope type, so we use that as our test case's input.

And since the macro's not doing anything yet, we just expect it to remove the attribute and not add any new members, so the expected expanded code is the same as the input, just without '@SlopeSubset'.

Finally, we need to let the test case know that it should expand the macro SlopeSubset using the SlopeSubsetMacro implementation. For that, we need to map the macro name to its implementing type in the 'testMacros' dictionary and pass that dictionary to the assertion function.

Let's run our tests now to check that what we have written so far actually works.

![Example of macro expansion][macro11]

[macro11]: ../../../images/notes/wwdc23/10166/macro11.jpg

# Diagnostics


# Wrap up

The key benefits of using Swift macros are:
- Code Consistency: Since macros generate code, it ensures that similar code snippets throughout the program are consistent. This is especially important when working in large teams where ensuring code consistency can be a challenge.
- Time Saving: Macros can automate repetitive tasks in your codebase. This can save a lot of time, especially on larger projects.
- Improved Readability and Maintainability: By abstracting away repetitive or complex code into a macro, the resulting code becomes easier to read and maintain.
- Reduced Errors: When repetitive code is generated by macros, it reduces the chance of introducing errors that can occur when manually writing similar code snippets.
In summary, while Swift macros might seem complex at first, especially for a new developer, they are a powerful tool to have in your programming toolkit. They can make your code cleaner, more efficient, and less prone to errors.


## Resources
[Have a question? Ask with tag wwdc2023-10166](https://developer.apple.com/forums/create/question?&tag1=235&tag2=662030)  
[Search the forums for tag wwdc2023-10166](https://developer.apple.com/forums/tags/wwdc2023-10166)  

## Related Videos
[Discover Observation in SwiftUI](https://developer.apple.com/videos/play/wwdc2023/10149)  
[Expand on Swift macros](https://developer.apple.com/videos/play/wwdc2023/10167)  
[What’s new in Swift](https://developer.apple.com/videos/play/wwdc2023/10164)  
[What’s new in Xcode 15](https://developer.apple.com/videos/play/wwdc2023/10165)
