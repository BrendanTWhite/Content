---
contributors: JohnBaer3
---

## ELI5 Summary of Macros: 
Imagine you're baking a cake, and you need to sift flour. You have to get out your sifter, pour in the flour, turn the handle... and you have to do this every single time you need sifted flour. Now imagine you had a magical kitchen helper who could do this for you. All you'd have to say is "sift flour" and it's done!
Swift macros are like that magical kitchen helper, but for your code. Instead of you having to write out the same lines of code over and over again, you just tell your macro (your kitchen helper) what to do. This might be something like "create a struct with these properties" or "set up a standard network request".
You define how the macro works one time, and then you can use it whenever you need to. It's a way to automate repetitive tasks and make your code easier to read and manage. This makes coding a lot faster and less prone to errors, especially as your projects get bigger and more complex.

The key benefits of using Swift macros are:
- Code Consistency: Since macros generate code, it ensures that similar code snippets throughout the program are consistent. This is especially important when working in large teams where ensuring code consistency can be a challenge.
- Time Saving: Macros can automate repetitive tasks in your codebase. This can save a lot of time, especially on larger projects.
- Improved Readability and Maintainability: By abstracting away repetitive or complex code into a macro, the resulting code becomes easier to read and maintain.
- Reduced Errors: When repetitive code is generated by macros, it reduces the chance of introducing errors that can occur when manually writing similar code snippets.
In summary, while Swift macros might seem complex at first, especially for a new developer, they are a powerful tool to have in your programming toolkit. They can make your code cleaner, more efficient, and less prone to errors.

# Overview

Macro roles
Diagnostics

Swift macros allow you to generate that repetitive code at compile time, making your app's codebases more expressive and easier to read.

Here we have a list of calculations that first-year students can use to practice their arithmetic skills. We have the result as an integer on the left and the calculation as a string literal on the right side of the tuple. Notice how this is repetitive, redundant, and even error prone because nobody can guarantee that the result actually matches the calculation.

```swift
let calculations = [
(1 + 1, "1 + 1"),
(2 + 3, "2 + 3"),
(7 - 3, "7 - 3"),
(5 - 2, "5 - 2"),
(3 * 2, "3 * 2"),
(3 * 5, "3 * 5"),
]
```

With Swift 5.9 we can define a stringify macro to simplify this. This macro also happens to be the one that is included in Xcode's template. The stringify macro only takes the calculation as a single parameter. At compile time it expands to the tuple that we saw before, guaranteeing that the calculation and the result match.

```swift
let calculations = [
	#stringify(1 + 1), 
	#stringify(2 + 3), 
	#stringify(7 - 3), 
	#stringify(5 - 2), 
	#stringify(3 * 2), 
	#stringify(3 * 5),
]
```

So how does this work? Let's take a look at the definition of the macro itself. Notice that it looks a lot like a function.

```swift
@freestanding(expression)
macro stringify(_ value: Int) -> (Int, String)
```

The stringify macro takes an integer as the input parameter and outputs a tuple containing an the result, an integer, and the calculation-- a string. If the arguments of the macro expression don't match the macro's parameters, or don't type check by themselves, the compiler will emit an error without applying the macro expansion. For example, if I pass a string literal to this macro, the compiler complains that 'String' is not convertible to expected argument type 'Int'.

![Example of repetitive code][example1]

[example1]: ../../../images/notes/wwdc23/10166/example1.jpg

This is different to, for example, C macros, which are evaluated at the pre-processor stage before type-checking. But it allows us to use all the powers that you know and love from Swift functions, like being able to make your macro generic.

Also note that this macro is declared with the freestanding expression macro role. This means that you can use the macro wherever you can use an expression, and that it will be indicated by the hash character, like we see with #stringify. Other kinds of macros are attached macros that can augment declarations. I will cover those later. After checking that all the arguments match the macro's parameters, the compiler performs the macro expansion. To see how that works, let's focus on a single macro expression.

## Macro plug-in

To perform the expansion, each macro defines its implementation in a compiler plug-in. The compiler will send the source code of the entire macro expression to that plug-in. The first thing that the macro plug-in does, is to parse the source code of the macro into a SwiftSyntax tree. This tree is a source-accurate, structural representation of the macro, and it will be the basis on which the macro operates. For example, our 'stringify' macro is represented in the tree as a macro expansion expression node. That expression has the macro name 'stringify'. And it takes a single argument, which is the infix operator plus applied to 2 and 3. What's really powerful about Swift macros is that that the macro's implementation is itself a program written in Swift and can perform any transformation to the syntax tree it wants. In our case, it generates a tuple like we saw before. It will then serialize the generated syntax tree into source code again and send it to the compiler, which will replace the macro expression by the expanded code.

![Example of macro expansion][macro1]

[macro1]: ../../../images/notes/wwdc23/10166/macro1.jpg

# Create a macro

Macros can be tested using unit tests, as they don't have side effects and the source code of syntax trees is easy to compare. The SwiftSyntax package includes an 'assertMacroExpansion' function for testing.
Besides freestanding expression macros, there are also freestanding declaration macros that expand to a declaration, and attached macros that augment the declaration they're attached to, spelled with an @. Examples include attached member macros that add new members to the type they're attached to. This can be used to automatically generate repetitive parts of the codebase, such as initializers and computed properties.


## A very simple example of the macro looks like:
```
@freestanding(expression)
macro stringify(_ value: Int) -> (Int, String)

let calculations = [
   #stringify(1 + 1),
   #stringify(2 + 3)
]
```
The above would return the array of tuples
```
[
 (1 + 1, "1 + 1"),
 (2 + 3, "2 + 3")
]
```

## Additional information
To create a new template, open Xcode, and click File, New, Package, then select the Swift Macro template. 

