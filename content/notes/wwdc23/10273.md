---
contributors: multitudes
---

## Chapters:
[0:00 - Introduction](https://developer.apple.com/videos/play/wwdc2023/10273/?time=0)  
[2:37 - Load 3D content](https://developer.apple.com/videos/play/wwdc2023/10273/?time=157)  
[6:27 - Components](https://developer.apple.com/videos/play/wwdc2023/10273/?time=387)  
[12:00 - User Interface](https://developer.apple.com/videos/play/wwdc2023/10273/?time=720)  
[27:51 - Play audio](https://developer.apple.com/videos/play/wwdc2023/10273/?time=1671)  
[30:18 - Material properties](https://developer.apple.com/videos/play/wwdc2023/10273/?time=1818)  
[33:25 - Wrap-up](https://developer.apple.com/videos/play/wwdc2023/10273/?time=2005)

# Reality Composer Pro
Reality Composer Pro is a developer tool for preparing RealityKit content to be used in your spatial computing app. 

![Reality Composer Pro Icon][composer]  

[composer]: ../../../images/notes/wwdc23/10273/composer.jpg

I'd recommend you familiarize yourself with the editor UI and features of Reality Composer Pro covered in the sessions:

[Explore materials in Reality Composer Pro - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10202)  
[Meet Reality Composer Pro - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10083)

We're looking at a topographical map of Yosemite National Park.

![Yosemite National Park][Yosemite]  

[Yosemite]: ../../../images/notes/wwdc23/10273/yosemite.jpg

Here, we've added a slider to morph between two different California landmarks. Now we're looking at Catalina Island off the coast of Los Angeles. 

![Catalina Island off the coast of Los Angeles.][Catalina]  

[Catalina]: ../../../images/notes/wwdc23/10273/catalina.jpg

We also have hovering 2D SwiftUI buttons positioned in 3D space that let you learn more about various points of interest in that map. 

# Load 3D content

In the above sessions, we made a Reality Composer Pro project that contains all the assets for our diorama arranged the way we want them. These tabs at the top each represent one root entity that we can load at runtime. We can put a lot of things into a scene and treat that as our fully assembled scene. Or we can put just a few and then treat that scene like a little reusable assemblage. We can make as many as we want. 

Let's see how we load this scene named DioramaAssembled at runtime.

We use entity's asynchronous initializer to make us an entity with the contents from our Reality Composer Pro package.
```swift
let entity = try await Entity(named: "DioramaAssembled", in: realityKitContentBundle)
```

We specify which entity we want to load using its string name, and we give it the bundle that our package produces. It will throw if it can't find anything in our Reality Composer Pro project by that name. realityKitContentBundle is a constant value that we autogenerate for you in your Reality Composer Pro package. This goes in a RealityView make closure. A RealityView is a new kind of SwiftUI view.  
It's the bridge between the worlds of SwiftUI and RealityKit.

```swift
RealityView { content in
	do {
		let entity = try await Entity(named: "DioramaAssembled", in: realityKitContentBundle)
		content.add(entity)
	} catch {
		// Handle error
	}
}
```

## Anatomy of a Reality Composer Pro package

If there are USD assets you're using in your Xcode project that you're not adding to a Reality Composer Pro project, we strongly encourage you to put those assets into a Swift Package, with an .rkassets directory inside it, like this. 

![Anatomy of a Reality Composer Pro package][Anatomy]  

[Anatomy]: ../../../images/notes/wwdc23/10273/anatomy.jpg

Xcode compiles the .rkassets folder into a format that's faster to load at runtime.  
The entity we just loaded is actually the root of a larger entity hierarchy. It has child entities and they in turn have child entities. It's everything we arranged in our Reality Composer Pro scene. If we wanted to address one of the entities lower down in the hierarchy, we could give it a name in Reality Composer Pro, and then at runtime, we could ask the scene to find that entity by its name.

![Anatomy of a Reality Composer Pro package][Anatomy2]  

[Anatomy2]: ../../../images/notes/wwdc23/10273/anatomy2.jpg

## Entity Component System.
Entities are a part of ECS, which stands for Entity Component System. ECS is what powers RealityKit and Reality Composer Pro.  

Let's take a step back and understand ECS. ECS has some close parallels to object-oriented programming but is different in some key ways. In the object-oriented programming world, the object has properties which are attributes that define its nature, and it has its own functionality. You write these properties and functions in a class that defines the object.  

![Entity Component System][ecs]  

[ecs]: ../../../images/notes/wwdc23/10273/ecs.jpg

### Entity
In the ECS world, an entity is any thing you see in the scene. They can also be invisible. They don't hold attributes or data though. We put our data into components instead.

### Components
Components can be added to or removed from entities at any time during app execution, which provides a way to dynamically change the nature of an entity.

### System
A system is where our behavior lives. It has an update function that's called once per frame. That's where you put your ongoing logic. In your system, you query for all entities that have a certain component on them, or configuration of components, and then you perform some action and store the updated data back into those components.

For a more in-depth discussion on ECS, check out:

[Dive into RealityKit 2 - WWDC21](https://developer.apple.com/videos/play/wwdc2021/10074)  
[Build spatial experiences with RealityKit - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10080) 

# Components
To add a component to an entity in Swift, you'd say entity.components.set() and provide the component value.

```swift
let component = MyComponent()
entity.components.set(component)
```
To do the same in Reality Composer Pro, select the entity you want either in the viewport or in the hierarchy.

![Entity Component System][component]  

[component]: ../../../images/notes/wwdc23/10273/component.jpg

Then, at the bottom of the Inspector Panel, click the Add Component button to bring up a list of all RealityKit's available components.

![Entity Component System][component2]  

[component2]: ../../../images/notes/wwdc23/10273/component2.jpg

We can add as many components to an entity as we want, and we can only add one of each type; it's a set. You'll also see any custom components you've made in this list as well. Let's see how we can use Reality Composer Pro to create our own custom components.

We're going to make those floating buttons that hover over specific points on our terrain so you can select them to see more information about that spot. We'll prepare a lot of that UI and functionality in code, but I want to show you how to mark these entities in Reality Composer Pro as the positions at which we want to show those floating buttons. 

![Entity Component System][component3]  

[component3]: ../../../images/notes/wwdc23/10273/component3.jpg

To do this, we're going to 
- add entities at locations above our terrain map, which will signify to the app that these are the places we want to show our floating buttons. 
- create a point of interest component to house our information about each place. 
- open the PointOfInterestComponent.swift in Xcode to edit it, adding properties like a name and a description. 
- In Reality Composer Pro, we'll add our new PointOfInterestComponent to each of our new entities
- fill in the properties' values. 

![Entity Component System][component4]  

[component4]: ../../../images/notes/wwdc23/10273/component4.jpg

Let's make our first location marker entity, Ribbon Beach, which is a place on Catalina Island. We click the plus menu and select Transform to make us a new invisible entity.

![Entity Component System][component5]  

[component5]: ../../../images/notes/wwdc23/10273/component5.jpg

We can name our entity Ribbon_Beach.

![Entity Component System][component6]  

[component6]: ../../../images/notes/wwdc23/10273/component6.jpg

Let's put this entity where Ribbon Beach actually is on the island.  

![Entity Component System][component7]  

[component7]: ../../../images/notes/wwdc23/10273/component7.jpg

We click on the Add Component button, but this time, we select New Component because we're going to make our own.
Let's give it a name, PointOfInterest.  

![Entity Component System][component8]  

[component8]: ../../../images/notes/wwdc23/10273/component8.jpg

Now it shows up in the Inspector Panel just like our other components do.
But what's this count property? 

![Entity Component System][component9]  

[component9]: ../../../images/notes/wwdc23/10273/component9.jpg

Let's open our new component in Xcode. In Xcode, we see that Reality Composer Pro created PointOfInterestComponent.swift for us.

Reality Composer Pro projects are Swift packages, and the Swift code we just generated lives here in the package. Looking at the template code, we see that that's where the count property came from.

![Entity Component System][component10]  

[component10]: ../../../images/notes/wwdc23/10273/component10.jpg

Let's have another property instead. We want each point of interest to know which map it's associated with so that when you change maps, we can fade out the old points of interest and fade in the appropriate ones. So we add an enumeration property, var region.  Let's make our enum region up here...  ...and give it two cases, since we're only building two maps right now: Catalina and Yosemite.  It can serialize as a string. We also conform it to the Codable protocol so that Reality Composer Pro can see it and serialize instances of it.
```swift
import RealityKit

public enum Region: String, Codable {
	case catalina
	case yosemite
 }
 
// Ensure you register this component in your app's delegate using:
// PointOfInterestComponent.registerComponent ()
public struct Point0fInterestComponent: Component, Codable { 
	var region: Region = .yosemite
	
	public init() {
	}
}
```

![Entity Component System][component11]  

[component11]: ../../../images/notes/wwdc23/10273/component11.jpg



Back in Reality Composer Pro, the count property has gone away and our new region property shows up. It has a default value of yosemite because that's what we initialized in the code, but we can override it here for this particular entity.

![Entity Component System][component12]  

[component12]: ../../../images/notes/wwdc23/10273/component12.jpg

If we override it, this value will only take effect on this particular entity. The rest of the point of interest components will have the default value of yosemite unless we override them too. 

We're using our PointOfInterestComponent like a signifier, a marker that we stick on these entities. These entities act like placeholders for where we'll put our SwiftUI buttons at runtime. We add our other Catalina Island points of interest the same way we just added Ribbon Beach. Let's run our app and see what our new custom component does.

Oh! It doesn't do anything. That's because we haven't written any code to handle these point of interest components yet. Let's do that.

# User interface

We have a new way of putting SwiftUI content into a RealityKit scene. This is called the Attachments API. We're going to combine attachments with our PointOfInterestComponent to create hovering buttons with custom data at runtime. Let's first see this in code and then I'll walk you through the data flow.

Attachments are a part of the RealityView. Let's first look at a simplified example to show the structure of a RealityView so we can see how SwiftUI views get into a RealityKit scene.
```swift
RealityView { _,_ in
	// load entities from your Reality Composer Pro package bundle
} update: { _,_ in
	// update your RealityKit entities
} attachments: {
	// SwiftUI Views
}
```
The RealityView initializer that we're going to use takes three parameters: a make closure, an update closure, and an attachments ViewBuilder. Fleshing this out a little, let's add a bare-minimum implementation of creating an Attachment View, a green SwiftUI button, and adding it to our RealityKit scene.

In the Attachments ViewBuilder, we make a normal SwiftUI view; we can use view modifiers and gestures and all the rest that SwiftUI gives us. We tag our View with any unique hashable. I've chosen to tag this button view with a fish emoji.
```swift
RealityView { _,_ in
	// load entities from your Reality Composer Pro package bundle
} update: { _,_ in
	// update your RealityKit entities
} attachments: {
	Button { ... }
		.background(.green)
		.tag ("🐠")
}
```
Later, when SwiftUI invokes our update closure, our button View has become an entity. It's stored in the attachments parameter to this closure, and we fish it out using the tag we gave it before. We can then treat it like any other entity. We can add it as a child of any existing entity in our scene, or we can add it as a new top-level entity in the content's entities collection.
```swift
RealityView { _,_ in
	// load entities from your Reality Composer Pro package bundle
} update: { _,_ in
	if let attachmentEntity = attachments.entity(for: "S") {
		content.add(attachmentEntity)
	}
} attachments: {
	Button { ... }
		.background(.green)
		.tag ("🐠")
}
```
And since it's become a regular entity, we can set its position so it shows up where we want in 3D, and we can add any components we want as well.

## RealityView attachments

Here's how data flows from one part of the RealityView to another. Let's look at the three parameters to this RealityView initializer. 

- The first is make, which is where you load your initial set-up scene from your Reality Composer Pro bundle as an entity and then add it to the RealityKit scene. 
- The second is update, which is a closure that will be called when there are changes to your view's state. Here, you can change things about your entities, like properties in their components, their position, and even add or remove entities from the scene. This update closure is not executed every frame. It's called whenever the SwiftUI view state changes. 
- The third is the attachments ViewBuilder. This is where you can make SwiftUI views to put into your RealityKit scene. 

![Entity Component System][component13]  

[component13]: ../../../images/notes/wwdc23/10273/component13.jpg

Your SwiftUI views start out in the attachments ViewBuilder, then they are delivered to you in the update closure in the attachments parameter.

![Entity Component System][component14]  

[component14]: ../../../images/notes/wwdc23/10273/component14.jpg

Here, you ask the attachments parameter if it has an entity for you using the same tag you gave to your button in the attachments ViewBuilder. If there is one, it vends you a RealityKit entity. In your update closure, you set its 3D position and add it to your RealityKit scene so you can see it floating in space wherever you want. 

![Entity Component System][component15]  

[component15]: ../../../images/notes/wwdc23/10273/component15.jpg

# Play audio


# Material properties




## Wrap Up


# Resources

[Have a question? Ask with tag wwdc2023-10273](https://developer.apple.com/forums/create/question?&tag1=740030&tag2=266&tag3=796030)  
[Search the forums for tag wwdc2023-10273](https://developer.apple.com/forums/tags/wwdc2023-10273)

# Check out also

[Build spatial experiences with RealityKit - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10080)  
[Develop your first immersive app - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10203)  
[Enhance your spatial computing app with RealityKit - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10081)  
[Explore materials in Reality Composer Pro - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10202)  
[Meet Reality Composer Pro - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10083)  
[Dive into RealityKit 2 - WWDC21](https://developer.apple.com/videos/play/wwdc2021/10074)
