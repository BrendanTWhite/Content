---
contributors: kyaw-codes, multitudes
---

## Chapters

[0:39 - Swift project update](https://developer.apple.com/videos/play/wwdc2023/10164/?time=39)  
[2:44 - Using if/else and switch statements as expressions](https://developer.apple.com/videos/play/wwdc2023/10164/?time=164)  
[3:52 - Result builders](https://developer.apple.com/videos/play/wwdc2023/10164/?time=232)  
[4:53 - type parameter packs](https://developer.apple.com/videos/play/wwdc2023/10164/?time=293)  
[9:34 - Swift macros](https://developer.apple.com/videos/play/wwdc2023/10164/?time=574)  
[19:47 - Swift foundation](https://developer.apple.com/videos/play/wwdc2023/10164/?time=1187)  
[23:25 - Ownership](https://developer.apple.com/videos/play/wwdc2023/10164/?time=1405)  
[27:59 - C++ interoperability](https://developer.apple.com/videos/play/wwdc2023/10164/?time=1679)  
[32:41 - What's new in Swift Concurrency](https://developer.apple.com/videos/play/wwdc2023/10164/?time=1961)  
[38:20 - FoundationDB: A case study](https://developer.apple.com/videos/play/wwdc2023/10164/?time=2300)  

## Description

Explore cutting edge language features and new APIs of Swift programming language.

- Swift project update
- Expressive code
- Swift everywhere

# Swift project update
Swift follows an open process for language evolution. New features or significant behavior changes are proposed and reviewed in the open on the Swift forums. If you want to follow along, you can find a dashboard of all the language proposals on the Swift website.

#### [swift.org/swift-evolution](swift.org/swift-evolution)
A year ago, we saw a significant restructuring of the Swift Project governance. The core team announced the formation of the Language Steering Group, which took on primary responsibility for oversight of the Swift language and standard library evolution. Since then, the language group has overseen 40 new language proposals, and we're going to talk about several of them today.  

But sometimes, individual language proposals come together as part of a wider theme, like the addition of Swift concurrency, which was introduced through ten separate proposals.  

For cases like this, the language steering group has introduced a new way of tying together these proposals, through vision documents.


These documents lay out a proposal for larger changes to the language. The first one to be accepted by the language steering group was a vision of Swift macros, a new feature in Swift 5.9 that we'll be covering later in this talk.

![vision documents][visionDocuments]

[visionDocuments]: ../../../images/notes/wwdc23/10164/visionDocuments.jpg

Of course, evolution of the language is only part of the work of the Swift community. A successful language needs much more than this. It needs great tooling, robust support for multiple platforms, and rich documentation. To oversee progress in this area, the core team is creating an ecosystem steering group parallel to the language steering group. This new structure was recently laid out in a blog post on Swift.org, a look out for further announcements about the formation of this new group soon.

![vision documents][visionDocuments2]

[visionDocuments2]: ../../../images/notes/wwdc23/10164/visionDocuments2.jpg

# Expressive code

Swift 5.9 includes what is probably our most commonly requested language enhancement, allowing if/else and switch statements to be used as expressions, providing a nice way to clean up your code.

### If/else and switch statements can now be used as expressions

For example, if you wanted to initialize a let variable based on some complex condition, you had to resort to tricks, like this hard-to-read compound ternary expression.
```swift
// Before 🤯
let bullet =
    isRoot && (count == 0 || !willExpand) ? ""
        : count == 0 ? "- "
        : maxDepth <= 0 ? "▹ " : "▿ "

// After 🤩
let bullet =
    if isRoot && (count == 0 || !willExpand) { "" }
    else if count == 0 { "- " }
    else if maxDepth <= 0 { "▹ " }
    else { "▿ " }
```

Another place where this helps is if you're initializing a global variable or a stored property. Single expressions work fine here, but if you wanted a condition, you had to use the trick of wrapping it in a closure that you then immediately executed.

```swift
let attributedName =
    AttributedString(markdown: displayName)
// before
let attributedName = {
    if let displayName, !displayName.isEmpty {
        AttributedString (markdown: displayName)
    } else {
        "Untitled"
    }
}()    
```
Now that an if statement can be an expression, you can just drop that clutter, leaving you with neater code.
```swift
let attributedName =
    if let displayName, !displayName.isEmpty {
        AttributedString (markdown: displayName)
    } else {
        "Untitled"
    }    
```

## Result builders enhancement

- Faster type checking  
- Improved code completion  
- More accurate error messages

Result builders have seen significant improvements including optimized type checking performance, code completion and improved error messages.

Previously, result builder code with errors would take a long time to fail, as the type checker explored the many possible invalid paths.

As of Swift 5.8, invalid code type checks much faster, and error messages on invalid code are now more precise. For example, previously, some invalid code could lead to misleading errors in a completely different part of the result builder. In Swift 5.7, you'd receive an error like this:

![][1]

[1]: ../../../images/notes/wwdc23/10164/IMG_9B4379D3B587-1.jpeg

when the mistake actually lies up here:

![][2]

[2]: ../../../images/notes/wwdc23/10164/IMG_FFC563B46E50-1.jpeg

## Generic improvement

Type inference enables using these types without needing to understand the advanced capabilities they're built with. For example, the standard library Array type uses generics to provide an array that works with any type of data that you might want to store. When you use an array, all you need to do is provide the elements. There's no need to specify an explicit argument for the element type because it can be inferred from the element values.  
Here's an example inspired by the Swift compiler's own codebase: An API that takes a request type and evaluates it to produce a strongly typed value. So you can make a request for a Boolean value and get back a Boolean result.
```swift
struct Request<Result> { ... }

struct RequestEvaluator {
    func evaluate<Result>(_ request: Request<Result>) -> Result
}

func evaluate(_ request: Request<Bool>) -> Bool {
    return RequestEvaluator ().evaluate(request)
}

Now, some APIs want to abstract not only over concrete types, but also the number of arguments that you pass in. So a function might take one request and return one result or two requests and return two results, or three and return three results.  
To support this, the generics system has to be used together with a mechanism to handle multiple argument lengths so that all of the types that you pass in are linked to the types that you get out.
```swift
let value = RequestEvaluator ().evaluate (request)

let (x, y) = RequestEvaluator () . evaluate (r1, r2)

let (x, Y, z) = RequestEvaluator ().evaluate (rl, I2, I3)
```

Before Swift 5.9, the only way to accomplish this pattern was by adding an overload for each specific argument length the API supported. But this approach has limitations. It forces an artificial upper bound on the number of arguments you can pass, resulting in compiler errors if you pass too many.
```swift
struct Request<Result> { ... }
struct RequestEvaluator {
    func evaluate<Result>(:) -> (Result)
    func evaluate<R1, R2> (_:_:) -> (R1, R2)
    func evaluate<R1, R2, R3> (_:_:_:) -> (R1, R2, R3)
    func evaluate<R1, R2, R3, R4>(_:_:_:_:)-> (R1, R2, R3, R4)
    func evaluate<R1, R2, R3, R4, R5>(_:_:_:_:_:) -> (R1, R2, R3, R4, R5)
    func evaluate<R1, R2, R3, R4, R5, R6>(_:_:_:_:_:_:) -> (R1, R2, R3, R4, R5, R6)
}
let results = evaluator. evaluate (r1, r2, r3, r4, r5, r6, r7)
```
In Swift 5.9, the generics system is gaining first-class support for this API pattern by enabling generic abstraction over argument length. This is done with a new language concept that can represent multiple individual type parameters that are "packed" together. This new concept is called a **type parameter pack**.  

![Each Result][eachResult]

[eachResult]: ../../../images/notes/wwdc23/10164/eachResult.jpg

Instead of accepting a single type parameter, Result, representing the result type of a single request, the evaluate function now accepts a separate request over `each Result` type.
```swift
func evaluate<each Result>(_: repeat Request<each Result>) -> (repeat each Result)
```

The function returns each result instance in parenthesis, which will either be a single value or a tuple containing each value.  
The evaluate function now handles all argument lengths with no artificial limit.
```swift
// Before 🤯
struct Request<Result> { ... }

struct RequestEvaluator {
    func evaluate<Result>(_:) -> (Result)
    func evaluate<R1, R2>(_:) -> (R1, R2)
    func evaluate<R1, R2, R3>(_:) -> (R1, R2, R3)
    func evaluate<R1, R2, R3, R4>(_:) -> (R1, R2, R3, R4)
}

// Call side
let results = RequestEvaluator.evaluate(r1, r2, r3, r4)

// After 🤩
struct RequestEvaluator {
    func evaluate<each Result>(_: repeat Request<each Result>) -> (repeat each Result)
}

// Call side
let results = RequestEvaluator.evaluate(r1, r2, r3, r4)
```

- The evaluate func now handles all arg lengths with no artificial limit
- Type inference makes APIs using parameter packs natural to use, without needing to know that the API is using them, i.e call-side might not even aware you are using type parameter pack under the hood.

To learn about how to write generic library APIs like these, check out:

[Generalize APIs with parameter packs - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10168)
  
# Swift Macros

With macros, you can extend the capabilities of the language itself, eliminating boilerplate and unlocking more of Swift's expressive power. Let's consider the ever-present assert function, which checks whether a condition is true.
```swift
// Normal assert func, not much info will be printed
assert(max(a, b) == c)
```

Assert will stop the program if the condition is false, but when that happens, you get very little information about what went wrong, just the file and line number. You'll need to add some logging or trap the program in the debugger to learn more.

![Macro Assert][macroAssert]

[macroAssert]: ../../../images/notes/wwdc23/10164/macroAssert.jpg

There have been attempts to improve on this. XCTest provides an assert-equal operation that takes the two values separately, so when things fail, you can at least see the two values that aren't equal.

![Macro Assert][macroAssert2]

[macroAssert2]: ../../../images/notes/wwdc23/10164/macroAssert2.jpg

But we still don't know which value is wrong here. Was it a, b, or the result of max? And this approach really doesn't scale for all of the kinds of checks we perform in asserts. If we go back to the original assertion, there is so much information here in the source code that we'd like to see in the log when our assertion fails. What was the code? What are the values of a, and b, and c? What did max produce? We couldn't improve this in Swift before without some custom feature, but macros make it possible.
```swift
// With "hash-assert" syntax is expanding the macro called "assert"
#assert(max(a, b) == c)
```

In this example, the "hash-assert" syntax is expanding the macro called "assert." The hash syntax might look familiar because Swift already has a few things with this same spelling, like hash-file, hash-selector, and hash-warning. 

Now the program is showing the code for the failing assertion, along with each of the values that contributed to the result.

![Macro Assert][macroAssert3]

[macroAssert3]: ../../../images/notes/wwdc23/10164/macroAssert3.jpg

In Swift, macros are APIs, just like types or functions, so you access them by importing the module that defines them. Like many other APIs, macros are distributed as packages. The assert macro here comes from the power asserts library, an open-source Swift package available on GitHub.

If you were to look into the macro package, you would find a macro declaration for assert. It is introduced with the "macro" keyword, but it looks a lot like a function. There's a single unlabeled Bool parameter for the condition to be checked. If this macro produced a value, that result type would be written with the usual arrow syntax.  
```swift
// Macro declarations
public macro assert(_ condition: Bool)
```
Uses of the macro will be type checked against the parameters. 

Most macros are defined as "external macros," specifying the module and type for a macro implementation via strings. The external macro types are defined in separate programs that act as compiler plugins. The Swift compiler passes the source code for the use of the macro to the plugin. The plugin produces new source code, which is then integrated back into the Swift program.
```swift
// Macros are separate programs
public macro assert(_ condition: Bool) = #externalMacro(
    module: "PowerAssertPlugin",
    type: "PowerAssertMacro"
)
```
Here, the macro is expanding the assertion into code that captures the individual values and where they should be displayed in the source code. You wouldn't want to write the boilerplate yourself, but the macro does it for you.

![Macro Assert][macroAssert4]

[macroAssert4]: ../../../images/notes/wwdc23/10164/macroAssert4.jpg

- You can extend the capabilities of the lang itself, eliminate boilerplate  
- Assert macro looks and feels like the function version, but, as it’s a macro, it can provide a richer experience.  
- Macros are APIs, just like types or functions, you access them by importing the module that defines them  
- Macros operate on well-typed inputs and produce code that augments your program (hence shipped with compile time type checking and helpful error message  
- Most macros are defined as “external macros”, so, you need to specify module and type for actual macro implementation via strings.
- The external macro types are defined in separate programs, that act as compiler plugins. Swift compiler passes the source code (`#assert(a == b)` in our case) for the use of the macro to the plugin, and the plugin produces new source code (the implementation), and that code is then integrated back into the Swift program.
- Macro declarations have one additional piece of info, their role.

### Freestanding macro roles
```swift
@freestanding(expression)
public macro assert(_ condition: Bool) = #externalMacro(
    module: "PowerAssertPlugin",
    type: "PowerAssertMacro"
)
```

- `assert` is labelled as freestanding because it uses the “hash” syntax. It is an expression macro as it can be used anywhere that one can produce a value. 
If you wanna see example of an expression macro, check out the new Foundation Predicate APIs.

The new Foundation Predicate APIs provide a great example of an expression macro. The predicate macro allows one to write predicates in a type-safe manner using closures. The resulting predicate values can then be used with a number of other APIs, including the Swift collection operations SwiftUI and SwiftData.
```swift
// Predicate expression macro
@freestanding(expression)
public macro Predicate<each Input>(
    _ body: (repeat each Input) -> Bool
) -> Predicate<repeat each Input>


let pred = #Predicate<Person> {
    $0.favoriteColor == .blue
}
let blueLovers = people.filter(pred)
```

### Case detection attached macros

Without using macros
```swift
// Testing for a specific enum case
enum Path {
    case relative(String)
    case absolute (String)
}

let absPaths = paths.filter { $0.isAbsolute }

extension Path {
    var isAbsolute: Bool {
        if case absolute = self { true }
        else { false }
    }
}

extension Path {
    var isRelative: Bool {
    if case relative = self { true }
    else { false }
    }
}
```

After using macros

![][8]

[8]: ../../../images/notes/wwdc23/10164/IMG_E033960D8BFB-1.jpeg

- Macro expand code (with use of `@CaseDetection` just like you define a property wrapper)

![][9]

[9]: ../../../images/notes/wwdc23/10164/IMG_991CDD186BB4-1.jpeg

![][10]

[10]: ../../../images/notes/wwdc23/10164/IMG_1972E7433E64-1.jpeg

- SwiftUI’s Observable macro works through composition of three macro roles.

![][11]

[11]: ../../../images/notes/wwdc23/10164/IMG_9A88DFF31094-1.jpeg

- Whenever you need to see how any macro expands, Xcode 15 comes up with “Expand Macros”

![][12]

[12]: ../../../images/notes/wwdc23/10164/IMG_540C7A2839B8-1.jpeg


- Swift foundation framework has significant performance improvement
    - Calendar calculations: 20% faster
    - Date formatting: 150% faster
    - JSON coding: 200-500% faster
- `~Copyable` (can be applied to struct and enum declarations) suppresses the implicit ability to copy a type. Once the type is non-copyable, you can give it a deinit (which will run when a value of the type goes out of scope), like you can a class.

```swift
struct FileDescriptor: ~Copyable {

    deinit {
    }
}
```

- Calling a `consuming` method or argument gives up ownership of a value to the method you called. Since our type is non-copyable, giving up ownership means you can no longer use the value.

```swift
struct FileDescriptor: ~Copyable {
    private var fd: CInt

    init(descriptor: CInt) { self.fd = descriptor }

    func write(buffer: [UInt8]) throws {
        // ...
    }

    consuming func close() {
        Darwin.close(fd)
    }

    deinit {
        Darwin.close(fd)
    }
}
```

![][13]

[13]: ../../../images/notes/wwdc23/10164/IMG_5C5DE0DE835F-1.jpeg

## C++ Interoperability

- In old days, the interoperability between Swift and C++ goes like this; Swift ↔ Objective-C ↔ C++
- Swift 5.9 introduces the ability to interact with C++ types and funcs directly from Swift.

![][14]

[14]: ../../../images/notes/wwdc23/10164/IMG_209572A99BE2-1.jpeg

Calling C++ from Swift

![][15]

[15]: ../../../images/notes/wwdc23/10164/IMG_56F71DE8FA87-1.jpeg

Calling Swift from C++

![][16]

[16]: ../../../images/notes/wwdc23/10164/IMG_F660BD866140-1.jpeg

- Expose most Swift APIs directly to C++ and many C++ idioms can be directly expressed in Swift, often automatically, but occasionally requiring some annotations to indicate the desired semantics
- Can integrate Swift code into CMake build by declaring Swift as one of the languages for the project and putting Swift files into a target.

```swift
// CMake

project(PingPong LANGUAGES CXX Swift)

add_library(PingPong
    Ping.swift
    Pong.swift
    TableTennisUtils.cpp
)
```

- Can mix C++ and Swift within a single target, and CMake will be compiled separately and link all of the appropriate supporting libraries and runtimes for both.

## Concurrency updates

![][17]

[17]: ../../../images/notes/wwdc23/10164/IMG_EBCC20E51B81-1.jpeg

- Actors can be implemented in different ways
- Custom actor executors allows a particular actor to implement its own synchronization mechanism

![][18]

[18]: ../../../images/notes/wwdc23/10164/IMG_FD8106603DBC-1.jpeg

- Synchronization of actors via dispatch queues is made possible because dispatch queue conforms to the new `SerialExecutor` protocol.
- Can provide own synchronization mechanism to use with actors by defining a new type that conforms to `SerialExecutor` protocol.

## Resources

[Evolving Swift Project Workgroups](https://www.swift.org/blog/evolving-swift-project-workgroups/)  
[Have a question? Ask with tag wwdc2023-10164](https://developer.apple.com/forums/create/question?&tag1=235&tag2=678030)  
[Search the forums for tag wwdc2023-10164](https://developer.apple.com/forums/tags/wwdc2023-10164)  
[Swift CMake Examples](https://github.com/apple/swift-cmake-examples)  
[Swift Evolution](https://apple.github.io/swift-evolution/)  
[The Future of Foundation](https://www.swift.org/blog/future-of-foundation/)  

# Related Videos

[Beyond the basics of structured concurrency - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10170)  
[Expand on Swift macros - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10167)  
[Generalize APIs with parameter packs - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10168)  
[Meet SwiftData - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10187)  
[Mix Swift and C++](https://developer.apple.com/videos/play/wwdc2023/10172)  
[Write Swift macros - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10166)  
[Swift concurrency: Behind the scenes - WWDC21](https://developer.apple.com/videos/play/wwdc2021/10254)  
