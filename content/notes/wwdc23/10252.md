---
contributors: dagronf, multitudes
---

## Chapters
[1:26 - What are previews](https://developer.apple.com/videos/play/wwdc2023/10252/?time=86)  
[3:42 - Preview syntax basics](https://developer.apple.com/videos/play/wwdc2023/10252/?time=222)  
[4:44 - Writing SwiftUI previews](https://developer.apple.com/videos/play/wwdc2023/10252/?time=284)  
[5:50 - Writing UIKit & AppKit previews](https://developer.apple.com/videos/play/wwdc2023/10252/?time=350)  
[6:08 - Demo: Putting writing previews into action](https://developer.apple.com/videos/play/wwdc2023/10252/?time=368)  
[11:39 - Writing previews for widgets](https://developer.apple.com/videos/play/wwdc2023/10252/?time=699)  
[15:58 - Previewing in library targets](https://developer.apple.com/videos/play/wwdc2023/10252/?time=958)  
[20:28 - Passing sample data into previews](https://developer.apple.com/videos/play/wwdc2023/10252/?time=1228)  
[22:08 - Previewing on devices for full fidelity and access to data](https://developer.apple.com/videos/play/wwdc2023/10252/?time=1328)  
[25:50 - Wrap-up](https://developer.apple.com/videos/play/wwdc2023/10252/?time=1550)  

## Intro
Building software, and especially apps, is a really iterative and creative process, so we want the fastest way to test our code.

# What are previews
A preview is a snippet of code that makes and configures a view. They are written at the top level of a source file, meaning they are not nested inside of any types or functions.  And they can literally be this simple. You use the #Preview macro, and return a view.

```swift
#Preview {
	MyView()
}
```

![What are previews][preview]

[preview]: ../../../images/notes/wwdc23/10252/preview.jpg

Previews are compiled into your app, right alongside the rest of your app code and your resources.

![What are previews][preview2]

[preview2]: ../../../images/notes/wwdc23/10252/preview2.jpg

Because your previews can access these symbols and resources, previews are really flexible.

But previews are also about iterating faster. When you edit any of the Swift code in your project, Xcode will do two things automatically. First, it'll examine the change you made and recompile the minimal amount of code. And then, second, re-run your preview.

This means that you can focus on writing and iterating on your code, and Xcode will automatically handle building, running, and updating your previews. And, once you have a preview defined, Xcode can run that preview in different contexts automatically without you needing to write any additional code. For example, you can test it in dark mode or different type sizes and orientations.

![What are previews][preview3]

[preview3]: ../../../images/notes/wwdc23/10252/preview3.jpg


## Previews are like tests
- They execute code in your project  
- Help you develop faster  
- Preview all layers of your app  

This isn’t a perfect analogy, but it might be helpful to think of previews similar to tests. Like tests, previews run real code in your real project. We're not emulating or interpreting code.  
Investing in writing tests and previews, ultimately helps you develop faster. Even a little bit can go a long way. Also, you can test and preview different layers of your app. For example, with tests, you can have high level UI tests that exercise a significant portion of your app’s functionality, and you can have smaller unit tests that test individual components. Similarly, you can have previews for views that encompass a lot of your application, and you can have previews that show individual leaf views.

# Writing previews

Regardless of what you preview, every preview you define has the same basic shape.

```swift
// Anatomy of a preview initializer

#Preview {
	Content()
}
```

First, start with the Preview macro initializer at the top level of a source file. Then, return one or more trailing closures of content. This is where you can configure your UI for exactly the scenario that you want to preview.  
And that’s all that’s required to make a preview, but you also optionally can configure the preview itself for even more flexibility. You can give it a name, and depending on the content of the preview, you might need or want to pass additional configuration in the initializer.
```swift
// Anatomy of a preview initializer
#Preview("Name", configuration) {
	Content()
}
```
We’ll look at some examples of this. Let’s talk about the kind of content you can preview. There are two main kinds: views and widgets. Views can come from SwiftUI, UIKit, or AppKit.

![What are previews][preview4]

[preview4]: ../../../images/notes/wwdc23/10252/preview4.jpg

For SwiftUI, just return any view that you’re working on. But you don’t have to just pass the view you’re working on; You can place it in whatever other views that you need. And this is helpful because oftentimes you want to work on a view in some broader context. For example, a view that’s always really intended to be in a List.
```swift
// SwiftUI
#Preview {
	List {
		CollageView(layout: .twoByTwoGrid)
	}
}
```


This is also the place to attach modifiers that provide data through the environment if the views you’re previewing need it.
```swift
// SwiftUI
#Preview {
	List {
		CollageView(layout: .twoByTwoGrid)
	}
	.environment(CollageLayoutStore.sample)
}
```

Previews are kind of like the scenes that you define at the top level of your app. Scenes serve as the entry points to your app. You set up data and you pass it through your views. Previews serve the same purpose, so you can use the preview to set up data and assets and then pass them into the views you’re previewing. When it comes to configuring the preview, you can give it a name. And view-based previews, like SwiftUI, support passing one or more configuration traits as a variadic argument list.

```swift
#Preview(“2x2 Grid”, traits: .landscapeLeft) {
   List {
      CollageView(layout: .twoByTwoGrid)
   }
   .environment(CollageLayoutStore.sample)
}
```

For example, you can set a starting orientation for the device that you’re previewing on. The shape of the API is the same for UIKit and AppKit. Instead of a SwiftUI view, just make a view controller, and configure it as needed.
```swift
#Preview {
   var controller = SavedCollagesController()
   controller.dataSource = CollagesDataStore.sample
   controller.layoutMode = .grid
   return controller
}
```

Beyond view controllers, you can also preview a UIView or NSView directly. So there’s lots of flexibility depending on what you’re trying to build.
```swift
#Preview(“Filter View”) {
    var view = CollageFilterDisplayView()
    view.filter = .bloom(amount: 15.0)
    view.imageData = …
    return view
}
```

I’m in the middle of writing an app that makes collages of images. I can pick the photos, I can pick the layout, and add filters.

![What are previews][preview5]

[preview5]: ../../../images/notes/wwdc23/10252/preview5.jpg

Let's go to Xcode and explore the features of the Preview canvas. I’ve started writing the view that lets me add a filter to an image. To help me iterate on this view, I’ll need a preview. To start, I’ll make sure the canvas mode is enabled by going to upper right of the editor and clicking the options menu.

![What are previews][preview6]

[preview6]: ../../../images/notes/wwdc23/10252/preview6.jpg

But even with the canvas mode enabled, the canvas stays hidden unless there is a preview defined in the file, so let’s add one.

When I start typing #Preview, Xcode suggests a preview for me. Once I accept the completion, Xcode builds and runs my preview, and my view appears right in the canvas.

![What are previews][preview7]

[preview7]: ../../../images/notes/wwdc23/10252/preview7.jpg

There are three different modes I can use to work on my view. These appear in the bottom left corner of the canvas. The first and default mode is the live or interactive mode. I spend most of my time in this mode because I can interact with my view in the canvas like dragging these sliders. I can also test animations and I can call and respond to asynchronous code.

The second mode is the selection, or static mode.
This mode takes a snapshot of my view and allows me to interact with the elements in the canvas. Clicking a view highlights the line of code that made it in the source editor. And if I double click certain text views, like this Label, it will move the focus to the source editor so I can quickly change it. Vignette is a more succinct label.

![What are previews][preview8]

[preview8]: ../../../images/notes/wwdc23/10252/preview8.jpg

Let’s talk about the environment. That is, the preview environment. The canvas is showing me my preview in light mode, but what if I want to see it in dark mode? I’m going to use the Device Settings popover in the canvas instead. In the bottom bar, click the controls icon to bring up the settings. Now I can enable dark mode or a specific dynamic type size.

![What are previews][preview9]

[preview9]: ../../../images/notes/wwdc23/10252/preview9.jpg

But what if I want to see what my view looks like in both color schemes at the same time? Well, for this, I’ll use the third mode of previews: variants.

![What are previews][preview10]

[preview10]: ../../../images/notes/wwdc23/10252/preview10.jpg

When I click the variants mode in the bottom of the canvas, I can pick which device setting I’d like to see all the values for, like color scheme, or all of the dynamic type sizes. I can inspect an individual variant by clicking it, and then I can page through each of the variants.  
Instead of a VStack, I’m gonna use a Form, which is perfect for groups of controls. And forms look great when the controls are placed in Sections. Let’s make each HStack be a Section. I can make these changes across all of my HStack instances by taking advantage of multi-cursor editing. I’ll select the first HStack, then press Command-Option-E to find and insert a cursor for each instance of HStack. I’ll change each of these to Section.  
I also want a header for each Section, which is provided in a second trailing closure. Arrow down and add the additional trailing closure.  
Let’s use the Labels we already have for these headers. Arrow back up to the Labels and press Command-Option-Right Brace to move the Labels down into the header. And wow, our view looks a lot better.

![What are previews][preview11]

[preview11]: ../../../images/notes/wwdc23/10252/preview11.jpg

These same features all work great with AppKit and UIKit views and view controllers, too.  

I’ll switch tab to the view controller that renders a filter using CoreImage, and switch the canvas back to live mode. Now, I’ve already made a preview for this view controller, and it looks really similar to the SwiftUI one. In the preview macro, I created a view controller and I passed it a sample image.
```swift
#Preview {
	let viewController = FilterRenderingViewController ()
	if let image = UIImage(named: "sample-001")?.cgImage {
		viewController.imageData = image
	}
	return viewController
}
```
But I’d like to test this image with a filter applied, so I’ll add the code to pass a filter to my view controller.
```swift
#Preview {
	let viewController = FilterRenderingViewController ()
	if let image = UIImage(named: "sample-001")?.cgImage {
		viewController.imageData = image
	}
	viewController.filter = Filter (
		bloomAmount: 1.0, 
		vignetteAmount: 1.0, 
		saturationAmount: 0.5
	}
	
	return viewController
}
```

Besides configuring my view controller, I can also configure the preview. Any preview can have an optional name as the first argument. And with view previews, like SwiftUI and UIKit, I can add one or more traits in a variadic list after the name.  
For example, I can set the preview to start in landscape.

![What are previews][preview12]

[preview12]: ../../../images/notes/wwdc23/10252/preview12.jpg

# Widgets

Two kinds of widgets you can preview

* Timeline provider
* Live Activities

### Timeline provider

* Widgets that use a timeline provider which produces individual entries
* Previews snapshots each timeline entry and shows them in the canvas
* Click on an entry to preview in the canvas
* Xcode communicates with the widget to show transitions with animations between each timeline entry

```swift
#Preview(as: .systemSmall) {
   FrameWidget()
} timelineProvider: {
   RandomCollageProvider()
}
```

* To display specific scenarios (rather than the entire timeline), use the `timeline` parameter to return just the timeline entries you're interested in
* Useful if there are (eg) specific transition scenarios which cause issues in your widget

```
#Preview(as: systemSmall) {
   FrameWidget()
} timeline: {
   let first = CollageLayout<Void>
      .preset_2x3_left.map { _ - in Color.gray }
      .fillSlice(at: 0, with: [.green, .orange, .cyan])
   let second = first.fillSlice(at: 1, with: [.blue])
   ImageGridEntry (layout: first)
   ImageGridEntry (layout: second)
}
```

* Clicking the 'play' button under the preview will animate between timeline states
* Pressing the 'pin' button in the upper left of the canvas will allow you to change code files without losing your canvas
* Useful for fine tuning your transitions

### Live Activities

* Basically the same api as for timeline provider widgets
* Need to provide a set of live activity attributes and a set of states

```swift
#Preview(as: .dynamicIsland(.compact), PizzaDeliveryAttributes()) {
   FoodOrderWidget()
} contentStates: {
   PizzaState.preparing
   PizzaState.baking
   PizzaState.outForDelivery
}
```

Check out the session ["Bring Widgets to Life"](https://developer.apple.com/videos/play/wwdc2023/10028) to learn more [(WWDCNotes)](https://www.wwdcnotes.com/notes/wwdc23/10028/)

## Previewing content in library targets

* Including frameworks, Swift packages or dynamic libraries
* Previews works great in these targets
* The first step in leveraging libraries is getting a sense of the **executable** that Previews uses for running your code
* Previews **need an executable, an app or a widget**, to launch and render previews

So if you don't have an app, how does this work?

* Previews uses three things to figure out which executable to use :-
  1. The source files you're working in
  2. The targets containing those files and all the dependencies of those targets 
  3. Previews then intersects those target dependencies with the targets in the scheme that you have selected.
* Previews will only select an app **that's in the active scheme**
* If Preview cannot find an app, it will make one on your behalf (XCPreviewAgent). If you see crash reports for XCPreviewAgent - it's because your code caused them :-)

You can take advantage of library targets to make previews work better.

* Create smaller schemes to focus on one part of your project
* Create small 'preview apps' to focus on one part of your project if the previews require info-plist settings (like photo access permissions)

## Development assets

* Can configure folders in build settings that are removed when the app is submitted to the app store.

## Previewing on a device

* The preview canvas includes a device picker that also includes any connected devices
* Preview will build and preview exclusively for this device (bypassing the simulator)
* All preview modes are available on the device
* Updates in the code automatically preview on the device

![Xcode preview canvas allowing selection of a 'real' device for previews][preview-device]
[preview-device]: ../../../images/notes/wwdc23/10252/preview-device.jpg

## Resources
[Have a question? Ask with tag wwdc2023-10252](https://developer.apple.com/forums/create/question?&tag1=266&tag2=333&tag3=713030)  
[Search the forums for tag wwdc2023-10252](https://developer.apple.com/forums/tags/wwdc2023-10252)

## Related Videos
[Bring widgets to life](https://developer.apple.com/videos/play/wwdc2023/10028)  
[What’s new in AppKit](https://developer.apple.com/videos/play/wwdc2023/10054)  
[What’s new in SwiftUI](https://developer.apple.com/videos/play/wwdc2023/10148)  
[What’s new in Xcode 15](https://developer.apple.com/videos/play/wwdc2023/10165)
