---
contributors: mikakruschel, multitudes
---

## Chapters
[0:00 - Intro](https://developer.apple.com/wwdc23/10187)  
[1:07 - Using the model macro](https://developer.apple.com/wwdc23/10187?time=67)  
[3:17 - Working with your data](https://developer.apple.com/wwdc23/10187?time=197)  
[7:02 - Use SwiftData with SwiftUI](https://developer.apple.com/wwdc23/10187?time=422)  
[8:10 - Wrap-up](https://developer.apple.com/wwdc23/10187?time=490)  

![SwiftData Logo][SwiftData]  

[SwiftData]: ../../../images/notes/wwdc23/10187/SwiftData.jpg

# Intro
- Using the model macro  
- Working with your data  
- Use SwiftData with SwiftUl  

SwiftData is a powerful framework for data modeling and management and enhances your modern Swift app. Like SwiftUI, it focuses entirely on code with no external file formats and uses Swift's new macro system to create a seamless API experience.

## Using the model macro @Model
- Powerful new Swift macro  
- Define your schema with code  
- Add SwiftData functionality to model types  

@Model is a new Swift macro that helps to define your model's schema from your Swift code. SwiftData schemas are normal Swift code, but when needed, you can annotate your properties with additional metadata. Using this schema, SwiftData adds powerful functionality to your model objects. 

Add `import SwiftData` and **`@Model`** to the model class and the schema is generated.
```swift
// Adding @Model to Trip

import SwiftData

@Model
class Trip {
var name: String 
var destination: String 
var endDate: Date 
var startDate: Date

var bucketList: [BucketListItem]? = []
var livingAccommodation: LivingAccommodation?
}
```

Models in SwiftData are the source of truth for your application's schema and drive the persistence experience. Part of this experience will transform the class' stored properties and turns them into persisted properties. 

SwiftData natively adapts your value type properties to be used as attributes right away. These properties include basic value types, like string, int, and float. They can also include more complex value types, such as structs, enums, and codable types too, including collections.

SwiftData models reference types as relationships. You can create links between your model types with relationships and collections of model types. @Model will modify all the stored properties on your type. You can influence how SwiftData builds your schema using metadata on your properties. With @Attribute, you can add uniqueness constraints. You can use @Relationship to control the choice of inverses and specify delete propagation rules. These change the behaviors of links between models. You can tell SwiftData not to include specific properties with the Transient macro. Here is our previous Trip example. I'll adjust SwiftData's schema generation by adding metadata to our stored properties.


- types can be value types, enums, structs, codable or collections of the value types
- `@Attribute(.unique)` for uniqueness constraint
- `@Relationship` for choice of inverses and delete propagation rules
- `@Transient` to exclude property from model
```swift
// Providing additional metadata

import SwiftData

@Model
class Trip {
    @Attribute(.unique) var name: String 
    var destination: String 
    var endDate: Date 
    var startDate: Date
    
    @Relationship(.cascade) var bucketList: [BucketListItem]? = []
    var livingAccommodation: LivingAccommodation?
}
```
To learn more about SwiftData modeling, check out the session:  
[Model your schema with SwiftData -                WWDC23](https://developer.apple.com/videos/play/wwdc2023/10195)  

## Model container

- Model container provides the persistent backend
  - Create container by specifying the list of model types to store
  - optionally provide `ModelConfiguration` with an url, CloudKit and group container identifiers, and migration options
  - `let container = try ModelContainer(for: [Trip.self, LivingAccommodation.self], configurations: ModelConfiguration(url: URL("path")))`
  - Or in SwiftUI use the modifier `.modelContainer(for: [Trip.self, LivingAccommodation.self])`
- **`ModelContext`**: interface to tracking updates, fetching data, saving changes, and even undoing those changes
  - In SwiftUI: `@Environment(\.modelContext) private var context`
  - `container.mainContext` for shared MainActor bound context
  - `let context = ModelContainer(container)` to instantiate new contexts for a given model container

In SwiftUI, you'll generally get the modelContext from your view's environment after you create your model container.

Outside the view hierarchy, you can ask the model container to give you a shared main actor bound context, or you can simply instantiate new contexts for a given model container. Once you have a context, you're ready to fetch data. SwiftData benefits from new Swift native types like predicate and fetch descriptor, as well as significant improvements to Swift's native sort descriptor.
```swift
import SwiftData

let container = try ModelContainer(for: [Trip.self, LivingAccommodation.self], configurations: ModelConfiguration(url: URL("path")))
```

```swift
import SwiftData 
import SwiftUI

@main
struct TripsApp: App {
    
    var body: some Scene {
        WindowGroup {
            ContentView()
        } 
        .modelContainer(for:
            [Trip.self, 
            LivingAccommodation.self])
        )
    }
}
```

## ModelContext
- Tracking updates  
- Fetching models  
- Saving changes  
- Undoing changes

```swift
import SwiftData 
import SwiftUI

struct ContextView : View {
    @Environment(\.modelContext) private var context
}
```

```swift
import SwiftData

let context = container.mainContext
```

```swift
import SwiftData

let context = ModelContext(container)
```
## Fetching Data
New in iOS 17, predicate works with native Swift types and uses Swift macros for strongly typed construction. It's a fully type checked modern replacement for NSPredicate.   

New Swift native types:  
- Predicate  
- FetchDescriptor  
Improvements to SortDescriptor  

## Predicate
Fully type checked  
`#Predicate` construction instead of text parsing  
Autocompleted keypaths

```swift
// Predicate examples

let tripPredicate = #Predicate<Trip> {
    S0.destination == "New York" && $0.name.contains("birthday")
}
```

```swift
// Predicate examples

let today = Date()
let tripPredicate = #Predicate<Trip> { 
    $0.destination == "New York" &&
    $0.name.contains("birthday") &&
    $0.startDate > today
}
```

```swift
let descriptor = FetchDescriptor<Trip>(predicate: tripPredicate)

let trips = try context.fetch (descriptor)
```
## SortDescriptor
- Updated to support all Comparable types  
- Swift native keypaths
```swift
let descriptor = FetchDescriptor<Trip>(
    sortBy: SortDescriptor(\Trip.name),
    predicate: tripPredicate
)
let trips = try context.fetch(descriptor)
```
## More FetchDescriptor options
- relationships to prefetch  
- result limits  
- exclude unsaved changes and more  

## Modifying Data
Basic operations
- Inserting  
- Deleting  
- Saving  
- Changing
```swift
var myTrip = Trip(name: "Birthday Trip", destination: "New York")

// Insert a new trip
context.insert(myTrip)

// Delete an existing trip
context.delete(myTrip)

// Manually save changes to the context
try context.save()
```

- The `@Model` macro modifies setters for change tracking and observation  
- Updates automatically by the ModelContext

To learn more about SwiftData containers and contexts and driving its operations, check out the session:  
[Dive deeper into SwiftData - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10196)  

# SwiftData in SwiftUI
- Seamless integration with SwiftUI  
- Easy configuration  
- Automatically fetch data and update views  

## View modifiers
- Configure data store with `.modelContainer` which is propagated throughout SwiftUI environment  
- Fetching in SwiftUI with **`@Query`**  
- No need for `@Published` and SwiftUI automatically updates  

```swift
// @Query

import SwiftData
import SwiftUI

struct ContentView: View  {
    @Query(sort: \.startDate, order: .reverse) var trips: [Trip]
    @Environment(\.modelContext) var modelContext
    
    var body: some View {
       NavigationStack() {
          List {
             ForEach(trips) { trip in 
                 // ...
             }
          }
       }
    }
}
```
## Observing changes

- No need for @Published  
- SwiftUl automatically refreshes

![SwiftData Logo][SwiftData2]  

[SwiftData2]: ../../../images/notes/wwdc23/10187/SwiftData2.jpg

## Resources
[Adopting SwiftData for a Core Data app](https://developer.apple.com/documentation/coredata/adopting_swiftdata_for_a_core_data_app)  
[Have a question? Ask with tag wwdc2023-10187](https://developer.apple.com/forums/create/question?&tag1=719030&tag2=698030)  
[Search the forums for tag wwdc2023-10187](https://developer.apple.com/forums/tags/wwdc2023-10187)  
[SwiftData](https://developer.apple.com/documentation/SwiftData)  

# Related Videos
[Build an app with SwiftData - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10154)  
[Discover Observation in SwiftUI - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10149)  
[Dive deeper into SwiftData - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10196)  
[Migrate to SwiftData - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10189)  
[Model your schema with SwiftData -                WWDC23](https://developer.apple.com/videos/play/wwdc2023/10195)  
[What’s new in Swift - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10164)  
[What’s new in SwiftUI - WWDC23](https://developer.apple.com/videos/play/wwdc2023/10148)  
